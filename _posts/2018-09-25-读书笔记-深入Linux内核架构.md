---
layout: original
title: "读书笔记：深入Linux内核架构"
date: 2018-09-25 10:00:00 +0800 
categories: 读书笔记
tags: [摘录, 持续更新, 技术书籍]
---
* content
{:toc}


> 一本介绍Linux内核技术方面的书籍。讲的很细，读起来很爽。<br/>
> 以下只是机械性的摘录，读完某阶段后再单独总结。

<!-- more -->

## 第一章：简介和概述
### 内核的组成部分
* 进程和线程： 进程有独立的内存空间，线程依赖于进程的内存空间。
* 命名空间：Linux没有全局变量（比如PID等），而是有自己的集合  --> 很容易的创建Linux子系统（容器）
> 如`chroot`。`chroot`是一种简单形式的命名空间，可以将进程限制到文件系统的某一部分。
* 进程间通信通过内核实现，具体方法是内存空间有专门的内核空间。
* 内核线程：无权访问用户空间，负责数据同步、分配进程等。使用`ps`命令时，带`[]`的就是内核线程。有的内核线程必须在指定CPU上运行，`[/num]`表明在哪个CPU上运行。
* 页帧：物理内存页； 页：虚拟地址页。
* 页表：将虚拟地址空间映射到物理地址空间。通常采用多级页表来减少存储空间。
* 伙伴系统：一种内存分配方式，可以一定程度上减少内存碎片（为什么？）
* slab分配器：负责分配小内存以及提供一般性的内核缓存。
* 模块：一种在内核空间运行的程序，可以动态的向内核添加功能。
* 链表处理：内核标准双链表实现方式。
* 所有内核代码都必须是并发安全的。


## 第二章：进程管理和调度
* 进程生命周期：运行、 等待、 睡眠、 终止。
* 僵尸进程：其占有的资源已经释放，但在进程表中仍有相应的表项。（因为残余的数据很少，所以僵尸进程影响不大）
> 产生原因：进程已经被另一个进程或用户杀死，但进程的父进程没有向内核确认子进程的终结。

* 进程优先级： 中断 > 系统调用 > 普通进程
* 进程产生的两种方式：1. `fork`. 生成当前进程的一个副本。 2. `exec`. 加载一个新程序。

#### 命名空间
创建方式：
1. `fork`或`clone`时有特定的选项可以控制与父进程共享命名空间还是建立新的命名空间。
2. `unshare`命令。 该系统调用可以将进程的某些部分从父进程分离，包括命名空间。

##### 实现
？？？ 不是很懂[P39]


#### 进程ID号
本节主要讲的是PID的管理。由于命名空间的使用，PID的管理变得比较复杂。

`pid`和`task_struct`的双向连接：`task_struct`中包含`pid`实例，`pid`实例可以通过遍历`tasks[type]`散列表找到相应的`task_struct`。

##### 生成唯一的PID
内核使用一个大的位图，每个比特代表一个PID。分配空闲PID等同于找位图中第一个值为0的比特。

### 进程管理相关的系统调用
#### 进程复制： fork/vfork[避免使用]/clone
fork： 理论上应该复制所有的内存页，但这样太耗时了。具体实现时只复制了其页表，即fork后父子进程地址空间指向相同的物理内存页；等写入时，再创建需要的页（写时复制，Copy-on-Write，COW）。

sys_fork: 从处理器寄存器中提取由用户空间提供的信息，调用do_fork函数；

do_fork: 负责进程复制。

#### 内核线程
内核线程是直接由内核本身启动的进程。内核线程实际上是将内核函数委托给独立的进程，独立执行页同步、记录日志等任务。

实现内核线程的4种方法：
1. kernel_thread
2. kthread_create
3. kthread_run
4. kthread_create_cpu

#### 启动新程序：execve
execve主要负责参数处理、UID管理、然后调用可执行文件（如ELF）；

释放原进程的所有资源、加载新数据等操作都是可执行文件完成的。

#### 退出进程
进程必须使用exit退出。（平常编程时，编译器会在main函数末尾自动添加相应调用）

do_exit将各个引用计数器减1，如果引用计数器为0，那么将相应的内存区域返还给内存管理模块。

> 也就是说，在系统层面是存在垃圾回收的，但是在进程内部，需要开发者自己实现（所以最方便的内存回收机制是定时退出进程重开 :)）

### 调度器的实现
调度器任务： 在程序之间共享CPU时间。（调度策略 + 上下文切换）
> schedule函数，kernel/sched.c

linux内核调度实现了优先调度，并且实现了Posix标准需要的两种软实时策略。

内核调度使用goto以生成最优的汇编语言代码。

原先的调度器是基于时间片调度的，时间复杂度是 $O(1)$[基于数组的优先级调度]，现在调度是基于等待时间的调度，时间复杂度 $O(log n)$[红黑树]


#### 核心调度器
##### 周期性调度器：scheduler_tick
1. 管理内核中调度相关的统计量
2. 激活负责当前进程的调度类的周期性调度方法。

##### 主调度器：schedule
> 该函数假定当前活动进程一定会被另一个进程取代

### 完全公平调度类

### 实时调度类











